 Теоретичний аналіз складності
|  |  |  |  | 
|  | O(n) | O(n^2) | O(n^2) | 
|  | O(n\log n) | O(n\log n) | O(n\log n) | 
|  | O(n) | O(n\log n) | O(n\log n) | 


- Вставки ефективні лише на малих масивах або майже відсортованих даних.
- Злиття стабільне й має гарантовану складність O(n\log n), але потребує додаткової пам’яті.
- Timsort комбінує обидва: на малих ділянках використовує вставки, а на великих — злиття. Це дає значний виграш у реальних сценаріях.

Очікувані результати
- Для малих масивів (1000 елементів): вставки можуть бути конкурентними.
- Для середніх і великих масивів (5000–10000 елементів): вставки стають дуже повільними (O(n^2)), злиття й Timsort працюють набагато швидше.
- Timsort зазвичай швидший за чисте злиття, бо:
- Використовує вставки на малих ділянках (де вони ефективні).
- Оптимізує злиття завдяки адаптивності до вже частково відсортованих даних

Висновки
- Теоретично: вставки — прості, але не масштабуються; злиття — стабільне й передбачуване; Timsort — гібрид, що поєднує переваги обох.
- Емпірично: вимірювання часу підтверджують теорію — Timsort стабільно швидший на великих масивах.
- Практично: саме тому програмісти рідко реалізують власні алгоритми сортування — вбудований Timsort у Python вже оптимізований для більшості сценаріїв.

